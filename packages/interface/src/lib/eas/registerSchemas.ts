/* eslint-disable no-console */
import { SchemaRegistry, type TransactionSigner, ZERO_ADDRESS } from "@ethereum-attestation-service/eas-sdk";
import "dotenv/config";
import { ethers } from "ethers";

import { eas, config } from "~/config";

/*
This file defines and registers the EAS schemas. 

Each schema's UID is generated by hashing the schema string, resolver address and revocable boolean.
This means applications and profiles share the same schema and are differentiated by the type.


Run: npx tsx src/lib/eas/registerSchemas
*/

const approvalSchema = "bytes32 type, bytes32 round";
const metadataSchema = "string name, string metadataPtr, uint256 metadataType, bytes32 type, bytes32 round";

const schemas = [
  { name: "Voter Approval", schema: approvalSchema },
  { name: "Application Approval", schema: approvalSchema },
  { name: "Application Metadata", schema: metadataSchema },
  { name: "Profile Metadata", schema: metadataSchema },
];

const provider = new ethers.AlchemyProvider(config.network.name, process.env.NEXT_PUBLIC_ALCHEMY_ID);

const wallet = new ethers.Wallet(process.env.WALLET_PRIVATE_KEY!).connect(provider);

const schemaRegistry = new SchemaRegistry(eas.contracts.schemaRegistry);
schemaRegistry.connect(wallet as unknown as TransactionSigner);

export async function registerSchemas(): Promise<{ name: string; uid: string }[]> {
  return Promise.all(
    schemas.map(async ({ name, schema }) => {
      const exists = await schemaRegistry
        .getSchema({
          uid: SchemaRegistry.getSchemaUID(schema, ZERO_ADDRESS, true),
        })
        .catch(console.error);

      if (exists) {
        return { name, ...exists };
      }

      return schemaRegistry.register({ schema, revocable: true }).then(async (tx) => ({ name, uid: await tx.wait() }));
    }),
  ).then((registered) => {
    registered.forEach((schema) => {
      console.log(`  ${schema.name}: ${schema.uid}`);
    });

    return registered;
  });
}

registerSchemas().catch(console.log);
